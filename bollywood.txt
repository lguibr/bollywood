File: .github/workflows/lint.yml
""""""
# File: .github/workflows/lint.yml (in new bollywood repo)
name: Bollywood-Lint

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest # Or pin to a specific version
""""""


File: .github/workflows/test.yml
""""""
# File: .github/workflows/test.yml (in new bollywood repo)
name: Bollywood-Test

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version-file: 'go.mod'
        cache: true
        cache-dependency-path: 'go.sum'

    - name: Test
      run: go test -v -race -covermode=atomic ./...
""""""


File: .gitignore
""""""
# File: .gitignore (in new bollywood repo)
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace cache
.gocache/

# Environment variables potentially stored in file
.env

# VS Code settings
.vscode/
""""""


File: README.md
""""""

# Bollywood Actor Library [![Go Test](https://github.com/lguibr/bollywood/actions/workflows/test.yml/badge.svg)](https://github.com/lguibr/bollywood/actions/workflows/test.yml) [![Go Report Card](https://goreportcard.com/badge/github.com/lguibr/bollywood)](https://goreportcard.com/report/github.com/lguibr/bollywood) [![Go Reference](https://pkg.go.dev/badge/github.com/lguibr/bollywood.svg)](https://pkg.go.dev/github.com/lguibr/bollywood)

Bollywood is a lightweight Actor Model implementation for Go, inspired by the principles of asynchronous message passing and state encapsulation. It aims to provide a simple yet powerful way to build concurrent applications using actors, channels, and minimal locking.

## Installation

```bash
go get github.com/lguibr/bollywood@latest
```

## Core Concepts

*   **Engine:** The central coordinator responsible for spawning, managing, and terminating actors.
*   **Actor:** An entity that encapsulates state and behavior. It implements the `Actor` interface, primarily the `Receive(Context)` method.
*   **PID (Process ID):** An opaque identifier used to reference and send messages to a specific actor instance.
*   **Context:** Provided to an actor's `Receive` method, allowing it to interact with the system (e.g., get its PID, sender PID, spawn children, send messages).
*   **Props:** Configuration object used to spawn new actors, specifying how to create an actor instance.
*   **Message:** Any Go `interface{}` value sent between actors.
*   **System Messages:** `Started`, `Stopping`, `Stopped` provide lifecycle hooks.

## Basic Usage

```go
package main

import (
	"fmt"
	"time"

	"github.com/lguibr/bollywood" // Use the new module path
)

// Define an actor struct
type MyActor struct {
	count int
}

// Implement the Actor interface
func (a *MyActor) Receive(ctx bollywood.Context) {
	switch msg := ctx.Message().(type) {
	case string:
		fmt.Printf("Actor %s received string: %s\n", ctx.Self().ID, msg)
		a.count++
	case int:
		fmt.Printf("Actor %s received int: %d\n", ctx.Self().ID, msg)
		// Example: Respond to sender
		if ctx.Sender() != nil {
			ctx.Engine().Send(ctx.Sender(), fmt.Sprintf("Processed %d", msg), ctx.Self())
		}
	case bollywood.Started:
        fmt.Printf("Actor %s started\n", ctx.Self().ID)
    case bollywood.Stopping:
        fmt.Printf("Actor %s stopping\n", ctx.Self().ID)
    case bollywood.Stopped:
        fmt.Printf("Actor %s stopped\n", ctx.Self().ID)
	default:
		fmt.Printf("Actor %s received unknown message type\n", ctx.Self().ID)
	}
}

// Actor producer function
func newMyActor() bollywood.Actor {
	return &MyActor{}
}

func main() {
	// Create an actor engine
	engine := bollywood.NewEngine()
	defer engine.Shutdown(1 * time.Second) // Ensure shutdown

	// Define properties for the actor
	props := bollywood.NewProps(newMyActor)

	// Spawn the actor
	pid := engine.Spawn(props)

	// Send messages
	engine.Send(pid, "hello world", nil) // nil sender for messages from outside actors
	engine.Send(pid, 42, nil)

    // Spawn another actor to receive a response
    responderProps := bollywood.NewProps(func() bollywood.Actor {
        return &MyActor{} // Using MyActor for simplicity, could be a different type
    })
    responderPID := engine.Spawn(responderProps)

    // Send a message and expect a response
    engine.Send(pid, 100, responderPID)


	// Allow time for messages to be processed
	time.Sleep(100 * time.Millisecond)

	// Stop is handled by engine.Shutdown
	// engine.Stop(pid)
    // engine.Stop(responderPID)

	// Allow time for stop messages (covered by Shutdown)
	// time.Sleep(50 * time.Millisecond)

    fmt.Println("Engine finished")
}

```

## Example Usage

See the [PonGo](https://github.com/lguibr/pongo) project for an example of how Bollywood can be used to build a concurrent game server.
""""""


File: actor.go
""""""

package bollywood

// Actor is the interface that defines actor behavior.
// Actors process messages sequentially received from their mailbox.
type Actor interface {
	// Receive processes incoming messages. The actor can use the context
	// to interact with the system (e.g., get self PID, sender PID, spawn children).
	Receive(ctx Context)
}
""""""


File: context.go
""""""

package bollywood

// Context provides information and capabilities to an Actor during message processing.
type Context interface {
	// Engine returns the Actor Engine managing this actor.
	Engine() *Engine
	// Self returns the PID of the actor processing the message.
	Self() *PID
	// Sender returns the PID of the actor that sent the message, if available.
	Sender() *PID
	// Message returns the actual message being processed.
	Message() interface{}
}

// context implements the Context interface.
type context struct {
	engine  *Engine
	self    *PID
	sender  *PID
	message interface{}
}

func (c *context) Engine() *Engine    { return c.engine }
func (c *context) Self() *PID         { return c.self }
func (c *context) Sender() *PID       { return c.sender }
func (c *context) Message() interface{} { return c.message }
""""""


File: engine.go
""""""
// File: bollywood/engine.go
package bollywood

import (
	"fmt"
	"strings" // Import strings
	"sync"
	"sync/atomic"
	"time"
)

// Engine manages the lifecycle and message dispatching for actors.
type Engine struct {
	pidCounter uint64
	actors     map[string]*process
	mu         sync.RWMutex // Protects the actors map
	stopping   atomic.Bool  // Indicates if the engine is shutting down
	mailboxMap sync.Map     // Store mailboxes separately for non-blocking send
}

// Mailbox returns the mailbox channel for a given PID.
// Used for potential non-blocking sends or external monitoring.
func (e *Engine) Mailbox(pid *PID) chan *messageEnvelope {
	if pid == nil {
		return nil
	}
	val, ok := e.mailboxMap.Load(pid.ID)
	if !ok {
		return nil
	}
	mailbox, ok := val.(chan *messageEnvelope)
	if !ok {
		// This should not happen if stored correctly
		fmt.Printf("ERROR: Invalid mailbox type found for PID %s\n", pid.ID)
		return nil
	}
	return mailbox
}

// NewEngine creates a new actor engine.
func NewEngine() *Engine {
	return &Engine{
		actors: make(map[string]*process),
		// mailboxMap is zero-value initialized, which is fine for sync.Map
	}
}

// nextPID generates a unique process ID.
func (e *Engine) nextPID() *PID {
	id := atomic.AddUint64(&e.pidCounter, 1)
	return &PID{ID: fmt.Sprintf("actor-%d", id)}
}

// Spawn creates and starts a new actor based on the provided Props.
// It returns the PID of the newly created actor.
func (e *Engine) Spawn(props *Props) *PID {
	if e.stopping.Load() {
		fmt.Println("Engine is stopping, cannot spawn new actors")
		return nil
	}

	pid := e.nextPID()
	proc := newProcess(e, pid, props)

	// Store mailbox in the sync.Map before starting the process
	e.mailboxMap.Store(pid.ID, proc.mailbox)

	e.mu.Lock()
	e.actors[pid.ID] = proc
	e.mu.Unlock()

	go proc.run() // Start the actor's run loop

	// Started message is now sent internally by process.run after actor creation

	return pid
}

// Send delivers a message to the actor identified by the PID.
func (e *Engine) Send(pid *PID, message interface{}, sender *PID) {
	if pid == nil {
		// fmt.Println("Engine: Attempted to send message to nil PID") // Reduce noise
		return
	}
	// Allow system messages during shutdown for cleanup
	_, isStopping := message.(Stopping)
	_, isStopped := message.(Stopped)
	isSystemMsg := isStopping || isStopped // Started is handled internally now

	if e.stopping.Load() && !isSystemMsg {
		// fmt.Printf("Engine is stopping, dropping user message %T for %s\n", message, pid.ID) // Reduce noise
		return
	}

	// Use sync.Map for mailbox lookup
	val, ok := e.mailboxMap.Load(pid.ID)
	if !ok {
		// Actor might have already stopped and removed its mailbox
		// Avoid logging during shutdown tests if actor was already stopped
		// if !e.stopping.Load() {
		// 	fmt.Printf("Actor %s mailbox not found, dropping message %T\n", pid.ID, message) // Reduce noise
		// }
		return
	}

	mailbox, ok := val.(chan *messageEnvelope)
	if !ok {
		fmt.Printf("ERROR: Invalid mailbox type found for PID %s\n", pid.ID)
		return
	}

	envelope := &messageEnvelope{
		Sender:  sender,
		Message: message,
	}

	// Use non-blocking send
	select {
	case mailbox <- envelope:
		// Message sent
	default:
		// Avoid logging during shutdown spam or for frequent messages
		// if !e.stopping.Load() {
		// 	fmt.Printf("Actor %s mailbox full, dropping message type %T\n", pid.ID, message) // Reduce noise
		// }
	}
}

// Stop requests an actor to stop processing messages and shut down.
// It signals the actor's stop channel; the actor's run loop handles cleanup.
func (e *Engine) Stop(pid *PID) {
	if pid == nil {
		// fmt.Println("Engine: Stop called with nil PID") // Reduce noise
		return
	}
	e.mu.RLock()
	proc, ok := e.actors[pid.ID]
	e.mu.RUnlock()

	if ok && proc != nil {
		// Directly signal the stop channel to ensure termination.
		// The process loop will handle calling the Stopping handler.
		select {
		case <-proc.stopCh: // Already closed
		default:
			close(proc.stopCh)
			// fmt.Printf("Engine closed stopCh for %s\n", pid.ID) // Debug log
		}
	} else {
		// fmt.Printf("Engine: Stop called for non-existent/already stopped actor %s\n", pid.ID) // Reduce noise
	}
}

// remove removes an actor process from the engine's tracking. Called by process.run defer.
func (e *Engine) remove(pid *PID) {
	if pid == nil {
		return
	}
	e.mu.Lock()
	delete(e.actors, pid.ID)
	e.mu.Unlock()
	// Remove mailbox from sync.Map as well
	e.mailboxMap.Delete(pid.ID)
	// fmt.Printf("Actor %s removed from engine\n", pid.ID) // Reduce noise
}

// Shutdown stops all actors and waits for them to terminate gracefully.
func (e *Engine) Shutdown(timeout time.Duration) {
	if !e.stopping.CompareAndSwap(false, true) {
		fmt.Println("Engine already shutting down")
		return
	}
	fmt.Println("Engine shutdown initiated...")

	// Collect PIDs to stop while holding lock
	e.mu.RLock()
	pidsToStop := make([]*PID, 0, len(e.actors))
	for _, proc := range e.actors {
		// Ensure proc and proc.pid are not nil before appending
		if proc != nil && proc.pid != nil {
			pidsToStop = append(pidsToStop, proc.pid)
		}
	}
	e.mu.RUnlock()

	fmt.Printf("Stopping %d actors...\n", len(pidsToStop))
	for _, pid := range pidsToStop {
		e.Stop(pid) // Stop now only closes stopCh
	}

	// Wait for actors to stop
	deadline := time.Now().Add(timeout)
	for time.Now().Before(deadline) {
		e.mu.RLock()
		remaining := len(e.actors)
		e.mu.RUnlock()
		if remaining == 0 {
			// fmt.Println("All actors stopped.") // Reduce noise
			break
		}
		// fmt.Printf("Shutdown waiting... %d actors remaining.\n", remaining) // Debug log
		time.Sleep(100 * time.Millisecond) // Increased sleep duration
	}

	// Check remaining actors after timeout
	e.mu.RLock()
	remainingCount := len(e.actors)
	if remainingCount > 0 {
		remainingActors := []string{}
		for pidStr := range e.actors {
			remainingActors = append(remainingActors, pidStr)
		}
		fmt.Printf("Engine shutdown timeout: %d actors did not stop gracefully: %s\n",
			remainingCount, strings.Join(remainingActors, ", "))
		// Force remove remaining actors from the map to prevent leaks if engine is reused (not typical)
		// Note: Their goroutines might still be running.
		e.mu.RUnlock() // Release RLock before acquiring Lock
		e.mu.Lock()
		// Clear the actors map
		for pidStr, proc := range e.actors {
			e.mailboxMap.Delete(pidStr) // Also remove from mailbox map
			// Attempt to close stopCh again just in case
			if proc != nil {
				select {
				case <-proc.stopCh:
				default:
					close(proc.stopCh)
				}
			}
		}
		e.actors = make(map[string]*process) // Clear the map
		e.mu.Unlock()
	} else {
		e.mu.RUnlock() // Release RLock if count was 0
	}

	fmt.Println("Engine shutdown complete.")
}
""""""


File: go copy.mod
""""""
module github.com/lguibr/pongo/bollywood

go 1.19
""""""


File: go.mod
""""""
// File: go.mod (in new bollywood repo)
module github.com/lguibr/bollywood

go 1.19 // Or your preferred Go version
""""""


File: messages.go
""""""

package bollywood

// --- System Messages ---

// Started is sent to an actor after its goroutine has started.
type Started struct{}

// Stopping is sent to an actor to signal it should prepare to stop.
// The actor should finish its current message and perform cleanup.
// No more user messages will be delivered after Stopping.
type Stopping struct{}

// Stopped is sent to an actor just before its goroutine exits.
// This is the final message an actor will receive.
type Stopped struct{}

// Failure is sent to a supervisor when a child actor crashes.
// (Not fully implemented in this basic version)
type Failure struct {
	Who   *PID
	Reason interface{}
}

// --- Message Envelope ---

// messageEnvelope wraps a user message with sender information.
type messageEnvelope struct {
	Sender  *PID
	Message interface{}
}
""""""


File: pid.go
""""""

package bollywood

// PID (Process ID) represents a unique reference to an actor instance.
type PID struct {
	ID string
	// We could add address/node info here for distributed actors later
}

// String returns the string representation of the PID.
func (pid *PID) String() string {
	return pid.ID
}
""""""


File: process.go
""""""
// File: bollywood/process.go
package bollywood

import (
	"fmt"
	"runtime/debug"
	"sync/atomic"
)

const defaultMailboxSize = 1024

// process represents the running instance of an actor, including its state and mailbox.
type process struct {
	engine  *Engine
	pid     *PID
	actor   Actor
	mailbox chan *messageEnvelope
	props   *Props
	stopCh  chan struct{} // Signal to stop the run loop
	stopped atomic.Bool   // Use atomic bool for safer concurrent checks
}

func newProcess(engine *Engine, pid *PID, props *Props) *process {
	return &process{
		engine:  engine,
		pid:     pid,
		props:   props,
		mailbox: make(chan *messageEnvelope, defaultMailboxSize),
		stopCh:  make(chan struct{}),
	}
}

// sendMessage sends a message to the actor's mailbox.
// (No changes needed here)
func (p *process) sendMessage(message interface{}, sender *PID) {
	// Optimization: Don't bother sending user messages if already stopped/stopping
	// Allow system messages (like Stopping, Stopped) through.
	_, isStopping := message.(Stopping)
	_, isStopped := message.(Stopped)
	if p.stopped.Load() && !isStopping && !isStopped {
		// fmt.Printf("Actor %s already stopped, dropping user message %T\n", p.pid.ID, message) // Reduce noise
		return
	}

	envelope := &messageEnvelope{
		Sender:  sender,
		Message: message,
	}

	// Use non-blocking send with a fallback to report if mailbox is full
	select {
	case p.mailbox <- envelope:
		// Message sent successfully
	default:
		// Avoid logging during shutdown spam or for frequent messages
		// if !p.engine.stopping.Load() {
		// 	fmt.Printf("Actor %s mailbox full, dropping message type %T\n", p.pid.ID, message) // Reduce noise
		// }
	}
}

// run is the main loop for the actor process.
func (p *process) run() {
	var stoppingInvoked bool // Track if Stopping handler has been called

	// Defer final cleanup and Stopped message
	defer func() {
		// Ensure actor is marked as stopped
		p.stopped.Store(true)

		// Recover from panic during Stopped processing
		defer func() {
			if r := recover(); r != nil {
				fmt.Printf("Actor %s panicked during final cleanup/Stopped processing: %v\n", p.pid.ID, r)
			}
			// Remove from engine *after* all cleanup attempts
			p.engine.remove(p.pid)
			// fmt.Printf("Actor %s goroutine exiting.\n", p.pid.ID) // Debug logging
		}()

		// Send the final Stopped message if actor was initialized and Stopping was invoked
		if p.actor != nil && stoppingInvoked {
			// fmt.Printf("Actor %s invoking final Stopped handler.\n", p.pid.ID) // Debug log
			p.invokeReceive(Stopped{}, nil) // Call Stopped handler
		} else if p.actor != nil && !stoppingInvoked {
			// This case might happen if the actor panicked *before* Stopping could be called.
			// We might still want to log Stopped, but it indicates an unusual exit.
			fmt.Printf("WARN: Actor %s stopped without Stopping handler being invoked (likely due to early panic).\n", p.pid.ID)
			p.invokeReceive(Stopped{}, nil) // Call Stopped handler anyway? Or just log? Let's call it.
		}

	}()

	// Defer panic recovery for the main loop and actor initialization
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("Actor %s panicked: %v\nStack trace:\n%s\n", p.pid.ID, r, string(debug.Stack()))
			// Ensure stopCh is closed on panic (non-blocking)
			// and mark as stopped immediately
			if p.stopped.CompareAndSwap(false, true) {
				select {
				case <-p.stopCh: // Already closed
				default:
					close(p.stopCh)
				}
				// Attempt to invoke Stopping handler on panic if not already invoked
				if p.actor != nil && !stoppingInvoked {
					// fmt.Printf("Actor %s invoking Stopping due to panic.\n", p.pid.ID) // Reduce noise
					p.invokeReceive(Stopping{}, nil)
					stoppingInvoked = true
				}
			}
		}
	}()

	// Create the actor instance
	p.actor = p.props.Produce()
	if p.actor == nil {
		panic(fmt.Sprintf("Actor %s producer returned nil actor", p.pid.ID))
	}
	// Send Started message *after* actor is created
	p.invokeReceive(Started{}, nil)

	// fmt.Printf("Actor %s goroutine started and processing messages.\n", p.pid.ID) // Debug logging

	// Main message processing loop
	for {
		select {
		case <-p.stopCh:
			// Stop signal received directly (e.g., from engine.Stop or panic recovery)
			// fmt.Printf("Actor %s received stop signal via stopCh.\n", p.pid.ID) // Debug logging
			if p.stopped.CompareAndSwap(false, true) {
				// If not already marked stopped (e.g., by Stopping message),
				// invoke Stopping handler now before exiting.
				if !stoppingInvoked {
					// fmt.Printf("Actor %s invoking Stopping due to stopCh closure.\n", p.pid.ID) // Reduce noise
					p.invokeReceive(Stopping{}, nil)
					stoppingInvoked = true
				}
			}
			return // Exit the loop, deferred functions will run

		case envelope, ok := <-p.mailbox:
			if !ok {
				// Mailbox closed unexpectedly? Should not happen with current design.
				fmt.Printf("Actor %s mailbox closed unexpectedly.\n", p.pid.ID)
				if p.stopped.CompareAndSwap(false, true) {
					select {
					case <-p.stopCh:
					default:
						close(p.stopCh)
					}
					if !stoppingInvoked {
						// fmt.Printf("Actor %s invoking Stopping due to unexpected mailbox closure.\n", p.pid.ID) // Reduce noise
						p.invokeReceive(Stopping{}, nil)
						stoppingInvoked = true
					}
				}
				return
			}

			// Check if stopped *after* receiving from mailbox,
			// but before processing, unless it's a system message.
			_, isStopping := envelope.Message.(Stopping)
			_, isStoppedMsg := envelope.Message.(Stopped) // Renamed to avoid conflict
			if p.stopped.Load() && !isStopping && !isStoppedMsg {
				// fmt.Printf("Actor %s is stopped, ignoring message type %T\n", p.pid.ID, envelope.Message) // Reduce noise
				continue
			}

			// Handle system messages directly
			switch msg := envelope.Message.(type) {
			case Stopping:
				// fmt.Printf("Actor %s processing Stopping message from mailbox.\n", p.pid.ID) // Debug logging
				if p.stopped.CompareAndSwap(false, true) { // Process only once
					if !stoppingInvoked {
						p.invokeReceive(msg, envelope.Sender)
						stoppingInvoked = true
					}
					// Signal the loop to stop *after* processing Stopping
					select {
					case <-p.stopCh: // Already closed by engine.Stop?
					default:
						close(p.stopCh)
					}
				}
			case Stopped:
				// Should be handled in defer, but log if received via mailbox.
				// This indicates a potential logic error elsewhere.
				fmt.Printf("WARN: Actor %s received unexpected Stopped message via mailbox.\n", p.pid.ID)
				if p.stopped.CompareAndSwap(false, true) {
					if !stoppingInvoked {
						// If Stopping wasn't called, call it now before Stopped
						p.invokeReceive(Stopping{}, nil)
						stoppingInvoked = true
					}
					p.invokeReceive(msg, envelope.Sender) // Call the received Stopped handler
					select {
					case <-p.stopCh:
					default:
						close(p.stopCh)
					}
				}
			default:
				// Process regular user message
				p.invokeReceive(envelope.Message, envelope.Sender)
			}
		}
	}
}

// invokeReceive calls the actor's Receive method within a protected context.
func (p *process) invokeReceive(msg interface{}, sender *PID) {
	// Create context for this message
	ctx := &context{
		engine:  p.engine,
		self:    p.pid,
		sender:  sender,
		message: msg,
	}

	// Call the actor's Receive method, recovering from panics within it
	func() {
		defer func() {
			if r := recover(); r != nil {
				fmt.Printf("Actor %s panicked during Receive(%T): %v\nStack trace:\n%s\n", p.pid.ID, msg, r, string(debug.Stack()))
				// Ensure stopCh is closed on panic within Receive
				// Use CompareAndSwap to ensure it's only closed once and stopping is invoked once
				if p.stopped.CompareAndSwap(false, true) {
					select {
					case <-p.stopCh:
					default:
						close(p.stopCh)
					}
					// Attempt to invoke Stopping handler on panic if not already invoked
					// We cannot set stoppingInvoked here directly, but the main run loop's
					// defer will handle the Stopped message correctly based on the atomic p.stopped flag.
					// We still call the Stopping handler here to attempt cleanup.
					p.invokeReceive(Stopping{}, nil) // Call stopping handler
				}
			}
		}()
		p.actor.Receive(ctx)
	}()
}
""""""


File: props.go
""""""

package bollywood

// Producer is a function that creates a new instance of an Actor.
type Producer func() Actor

// Props is a configuration object used to create actors.
type Props struct {
	producer Producer
	// We could add mailbox configuration, supervisor strategy, etc. here later
}

// NewProps creates a new Props object with the given actor producer.
func NewProps(producer Producer) *Props {
	if producer == nil {
		panic("bollywood: producer cannot be nil")
	}
	return &Props{
		producer: producer,
	}
}

// Produce creates a new actor instance using the configured producer.
func (p *Props) Produce() Actor {
	return p.producer()
}
""""""


